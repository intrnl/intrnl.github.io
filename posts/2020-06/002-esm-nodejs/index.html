<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <title>./intrnl</title> <meta content="very personal site" name=description> <meta content=en_US property=og:locale> <meta content=./intrnl property=og:site_name> <link href=https://font-depot.now.sh/jetbrains-mono-nl/font.css rel=stylesheet> <link href=/css/index.css rel=stylesheet> <base href=/ > <title>ESM in Node.js is still full of landmines - ./intrnl</title><meta content="ESM in Node.js is still full of landmines" property=og:title data-svelte=svelte-1727nge><meta content="And how we can do our parts to fix it" property=og:description data-svelte=svelte-1727nge><link href=/css/syntax.css rel=stylesheet data-svelte=svelte-1727nge> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{data:{title:"ESM in Node.js is still full of landmines",description:"And how we can do our parts to fix it",date:"2020-06-06T00:00:00.000Z"},html:"\u003Cp\u003EI can't tell how long I've been waiting for ES Modules support to hit Node.js,\nand when Node.js 13.2.0 finally unflagged the experimental support, I was\npretty excited for the future where we're no longer bound to using CommonJS.\u003C\u002Fp\u003E\n\u003Cp\u003EExcept I've forgotten all about it.\u003C\u002Fp\u003E\n\u003Cp\u003ERecently, I published several packages to NPM, which I also use in my projects,\nboth public and private. They all use ES Modules, with no transformation step\ndone before publishing, it's only using the \u003Ccode\u003Etype\u003C\u002Fcode\u003E field of \u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E to\nlet Node.js know that it's an ES Module package. I've been thinking that I\nshould add unit testing to them too so I don't have any worries about\naccidentally breaking stuff, but here's where it hits me.\u003C\u002Fp\u003E\n\u003Cp\u003EAs of the writing of this post, there hasn't been any test runners that fully\nsupports ES Modules in Node.js.\u003C\u002Fp\u003E\n\u003Cp\u003ENot only that, I've realized that my code doesn't exactly work on Node.js\neither because it does not use the widely used \u003Ccode\u003Emodule\u003C\u002Fcode\u003E field of \u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E\nthat most packages use. So it would import the CommonJS version of the package,\nand throws an error because you can't use named imports on them.\u003C\u002Fp\u003E\n\u003Cp\u003EThis isn't something that Node.js committee can fix by themselves, they also\nneed our help to do our parts as well.\u003C\u002Fp\u003E\n\u003Ch2\u003EHow we can fix it\u003C\u002Fh2\u003E\n\u003Cp\u003ETo mark an entire package as being fully written in ESM, you know full well\nfrom above that you can set the \u003Ccode\u003Etype\u003C\u002Fcode\u003E field to \u003Ccode\u003Emodule\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-json\"\u003E\u003Ccode class=\"language-json\"\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token property\"\u003E\"name\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\"awesome-library\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token property\"\u003E\"type\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\"module\"\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis should be fine for most packages, however it comes with a downside where\nolder Node.js versions can't actually use them.\u003C\u002Fp\u003E\n\u003Cp\u003EHowever, if you have a transformation step going, you can use the \u003Ccode\u003Eexports\u003C\u002Fcode\u003E\nfield instead to indicate that there are multiple versions of the same entry\npoints.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-json\"\u003E\u003Ccode class=\"language-json\"\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token property\"\u003E\"exports\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token property\"\u003E\".\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n      \u003Cspan class=\"token property\"\u003E\"require\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\".\u002Fdist\u002Fcjs\u002Fawesome-library.js\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n      \u003Cspan class=\"token property\"\u003E\"import\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\".\u002Fdist\u002Fmodule\u002Fawesome-library.js\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token property\"\u003E\".\u002Fsubmodule\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n      \u003Cspan class=\"token property\"\u003E\"require\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\".\u002Fdist\u002Fcjs\u002Fsubmodule\u002Findex.js\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n      \u003Cspan class=\"token property\"\u003E\"import\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\".\u002Fdist\u002Fmodule\u002Fsubmodule\u002Findex.js\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAs with anything, this also comes with a downside with end users not being able\nto poke around random files on the library, which might not be bad, but it\ncomes off as a breaking change for them.\u003C\u002Fp\u003E\n\u003Cp\u003ETo remedy that, you are able the directories that your end users can use.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-json\"\u003E\u003Ccode class=\"language-json\"\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token property\"\u003E\"exports\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token property\"\u003E\".\u002Flib\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\".\u002Flib\u002Findex.js\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token property\"\u003E\".\u002Flib\u002F\"\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\".\u002Flib\u002F\"\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003EConclusion\u003C\u002Fh2\u003E\n\u003Cp\u003EThe morale of the story? Avoid using experimental features whenever you can,\nbut if I were to be honest, if we always avoid them, then we can't provide the\nactual opinion and feedback that can be used to make that feature better, and\nhopefully make them suitable for production usage.\u003C\u002Fp\u003E"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.202edb9f.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.202edb9f.js")}document.head.appendChild(s)</script> </head> <body> <div id=root><nav><span><a href=/ rel=prefetch>Home</a></span><span><a href=/projects rel=prefetch>Projects</a></span><span><a href=/posts/page/1 rel=prefetch>Posts</a></span></nav><main><header><h1>ESM in Node.js is still full of landmines</h1> <p>And how we can do our parts to fix it</p> <small>Posted on 2020-06-06T00:00:00.000Z</small></header><div><p>I can't tell how long I've been waiting for ES Modules support to hit Node.js, and when Node.js 13.2.0 finally unflagged the experimental support, I was pretty excited for the future where we're no longer bound to using CommonJS.</p> <p>Except I've forgotten all about it.</p> <p>Recently, I published several packages to NPM, which I also use in my projects, both public and private. They all use ES Modules, with no transformation step done before publishing, it's only using the <code>type</code> field of <code>package.json</code> to let Node.js know that it's an ES Module package. I've been thinking that I should add unit testing to them too so I don't have any worries about accidentally breaking stuff, but here's where it hits me.</p> <p>As of the writing of this post, there hasn't been any test runners that fully supports ES Modules in Node.js.</p> <p>Not only that, I've realized that my code doesn't exactly work on Node.js either because it does not use the widely used <code>module</code> field of <code>package.json</code> that most packages use. So it would import the CommonJS version of the package, and throws an error because you can't use named imports on them.</p> <p>This isn't something that Node.js committee can fix by themselves, they also need our help to do our parts as well.</p> <h2>How we can fix it</h2> <p>To mark an entire package as being fully written in ESM, you know full well from above that you can set the <code>type</code> field to <code>module</code>.</p> <pre class=language-json><code class=language-json><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"awesome-library"</span><span class="token punctuation">,</span>
  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"module"</span>
<span class="token punctuation">}</span>
</code></pre> <p>This should be fine for most packages, however it comes with a downside where older Node.js versions can't actually use them.</p> <p>However, if you have a transformation step going, you can use the <code>exports</code> field instead to indicate that there are multiple versions of the same entry points.</p> <pre class=language-json><code class=language-json><span class="token punctuation">{</span>
  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"."</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./dist/cjs/awesome-library.js"</span><span class="token punctuation">,</span>
      <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./dist/module/awesome-library.js"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">"./submodule"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./dist/cjs/submodule/index.js"</span><span class="token punctuation">,</span>
      <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./dist/module/submodule/index.js"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>As with anything, this also comes with a downside with end users not being able to poke around random files on the library, which might not be bad, but it comes off as a breaking change for them.</p> <p>To remedy that, you are able the directories that your end users can use.</p> <pre class=language-json><code class=language-json><span class="token punctuation">{</span>
  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"./lib"</span><span class="token operator">:</span> <span class="token string">"./lib/index.js"</span><span class="token punctuation">,</span>
    <span class="token property">"./lib/"</span><span class="token operator">:</span> <span class="token string">"./lib/"</span>
<span class="token punctuation">}</span>
</code></pre> <h2>Conclusion</h2> <p>The morale of the story? Avoid using experimental features whenever you can, but if I were to be honest, if we always avoid them, then we can't provide the actual opinion and feedback that can be used to make that feature better, and hopefully make them suitable for production usage.</div></main></div> 